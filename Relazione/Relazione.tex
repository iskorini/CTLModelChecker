\documentclass[a4paper, 10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[makeroom]{cancel}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage[]{acronym}
\usepackage{syntax}
\usepackage{newfloat}
\usepackage{float}
%\usepackage[LGRgreek]{mathastext}
\usepackage[osf,sc]{mathpazo}
\usepackage{eulervm}
\usepackage{MnSymbol}
\usepackage{listings}
\usepackage{caption}
\usepackage{color}
\usepackage{algorithm}% http://ctan.org/pkg/algorithms
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx

\title{Relazione per l'approfondimento su Computational Tree Logic}
\author{Filippo Mameli, Federico Schipani}
\makeindex

\let\syntleft\relax
\let\syntright\relax
\grammarparsep=30pt
\DeclareFloatingEnvironment[
  fileext   = logr,
  listname  = {List of Grammars},
  name      = Grammatica,
  placement = H
]{Grammar}

\newtheorem{prop}{Proprietà}
\newtheorem{defn}{Definizione}
\newtheorem{theor}{Teorema}[section]
\numberwithin{equation}{theor}



\makeatletter
\newcommand{\newalgname}[1]{%
  \renewcommand{\ALG@name}{#1}%
}
\newalgname{Algoritmo}% All algorithms will be called "Algorithme"
\renewcommand{\listalgorithmname}{Lista di \ALG@name s}
\makeatother



\begin{document}
\maketitle
\tableofcontents
\section{Introduzione a \ac*{CTL}}
\acf{CTL} è una logica proposta da Clarke e Emerson per far fronte ad alcuni problemi noti di \ac{LTL}. In \ac{LTL} il concetto di tempo è lineare, ciò vuol dire che in un determinato momento abbiamo un unico possibile futuro. Ciò comporta che una determinata formula $\phi$ è valida in uno stato $s$, se e solo se tutte le possibili computazioni che partono da quello stato soddisfano la formula. Più formalmente:
\begin{equation}\label{first}
    s \models \phi \iff \pi \models \phi \ \forall \  paths \  \pi \ che\  inizia\  in\  s
\end{equation}
Come si può notare dalla Formula \eqref{first} non è possibile imporre facilmente condizioni di soddisfacibilità solo su alcuni di questi path. Dato uno stato $s$, verificare che solo alcune computazioni soddisfano una formula $\phi$ può essere fatto usando la dualità tra l'operatore universale ed esistenziale. Quindi verificare  $ s \models  \exists \phi $ corrisponde a verificare $s \models \forall \neg \phi $. Se quest'ultima non è soddisfatta allora esisterà una computazione che soddisferà $\phi$, altrimenti non esisterà. \par
Questo sotterfugio non è possibile usarlo per proprietà più complicate. Per esempio la proprietà
\begin{prop}
\label{prop:first}
Per ogni computazione è sempre possibile ritornare in uno stato iniziale 
\end{prop}
non è possibile esprimerla in \ac{LTL}. Un tentativo potrebbe essere $\square\lozenge start$, dove $start$ indica uno stato iniziale. Tuttavia una formula di questo tipo è troppo forte, in quanto questa formula impone che una computazione ritorni sempre in uno stato iniziale, e non soltanto eventualmente. \par
\ac{CTL} risolve questi problemi introducendo una nozione di tempo che si basa sulle diramazioni. Quindi non abbiamo più un infinita sequenza di stati, ma un infinito albero di stati. Questo comporta che in un determinato momento avremo diversi possibili futuri.\par
La semantica di questa logica è definita in termini di infiniti alberi, dove ogni diramazione rappresenta un singolo percorso. L'albero quindi è una fedele rappresentazione di tutti i possibili path, e si può facilmente ottenere schiudendo il \ac{TS}.\par
In \ac{CTL} sono presenti quantificatori, definiti sui path, di tipo esistenziale ($\exists$) ed universale ($\forall$). La Proprietà $\exists\lozenge \psi$ dice che esiste una computazione che soddisfa $\lozenge\psi$, più intuitivamente vuol dire che esisterà almeno una possibile computazione nel quale uno stato $s$ che soddisfa $\psi$ verrà eventualmente raggiunto. Tuttavia questo non esclude la possibilità che ci possono essere computazioni per le quali questa proprietà non viene soddisfatta.
La proprietà \ref{prop:first} citata in precedenza è possibile ottenerla annidando quantificatori esistenziali ed universali in questo modo:
\begin{equation}
\label{second}
\forall\square\exists\lozenge start
\end{equation}
La Formula \eqref{second} si legge come: in ogni stato ($\square$) di ogni possibile computazione ($\forall$), è possibile ($\exists$) eventualmente ritornare in uno stato iniziale ($\lozenge start$).


\subsection{Sintassi di \ac{CTL}} 
\ac{CTL} ha una sintassi a due livelli, dove le formule sono classificate in \textit{formule sugli stati} e \textit{formule sui path}. 

\begin{Grammar}
	\begin{grammar}	
	
	\centering
	<$\boldsymbol{\phi}$> ::= true | a | $\boldsymbol{\phi}_{1} \wedge \boldsymbol{\phi}_{2}$ | $\neg \boldsymbol{\phi}$ | $	\exists \varphi$ | $\forall \varphi$ 
	
	\end{grammar}
	\caption{Grammatica per le formule sugli stati}\label{gra:stateformulae}
\end{Grammar}
Le prime sono definite dalla Grammatica \ref{gra:stateformulae} dove $a \in AP$ e $\varphi$ è una formula sui path.
\begin{Grammar}
	\begin{grammar}	
	
	\centering
	<$\varphi$> ::= $\bigcircle \boldsymbol{\phi}$ | $\boldsymbol{\phi}_{1}\ \boldsymbol{U}\  \boldsymbol{\phi}_{2}$ 
	
	\end{grammar}
	\caption{Grammatica per le formule sui path}\label{gra:pathformulae}
\end{Grammar}
Le \textit{formule sui path} sono invece definite dalla Grammatica \ref{gra:pathformulae}.
Intuitivamente si può dire che le formule sugli stati esprimono una proprietà su uno stato, mentre le formule sui path esprimono proprietà sui infinite sequenze di stati. Per esempio la formula $\bigcircle \phi$ è vera per un path se lo stato successivo, in quel path, soddisfa $\phi$. Una formula sugli stati può essere trasformata in una formula sui path aggiungendo all'inizio un quantificatore esistenziale ($\exists$) o universale ($\forall$). Per esempio la formula $\exists \varphi$ è valida in uno stato se esiste almeno un percorso che soddisfa $\varphi$.

\subsection{Semantica di \ac{CTL}}

Le formule \ac{CTL} sono interpretate sia sugli stati che sui path di un \ac{TS}. Formalmente, dato un \ac{TS}, la semantica di una formula è definita da due relazioni di soddisfazione: una per le formule di stato ed una per le formule di path.
Per le formule di stato è un tipo di relazione tra gli stati del \ac{TS} e la formula di stato. Si scrive che $s \models \boldsymbol{\phi}$ se e solo se la formula di stato $\boldsymbol{\phi}$ è vera nello stato $s$.\par
Per le formule di path la relazione $\models$ è una relazione definita tra un frammento di path massimale nel \ac{TS} e una formula di path. Si scrive che $\pi \models \varphi$ se e solo se il path $\pi$ soddisfa la formula $\varphi$.
\begin{defn}
Sia $a \in AP$ una proposizione atomica, $TS = (S, act, \rightarrow, I, AP, L)$ un \acf{TS} senza stati terminali, stati $s \in S$, $\boldsymbol{\phi}$, $\boldsymbol{\Psi}$ formule \ac{CTL} di stato e $\varphi$ una formula \ac{CTL} di path. La relazione di soddisfazione $\models$ per le formule di stato è definita come:
$$s \models a \iff a \in L(s)$$
$$s \models \neg \boldsymbol{\phi} \iff not\ s \models \boldsymbol{\phi}$$
$$s \models \boldsymbol{\phi} \wedge \boldsymbol{\Psi} \iff (s \models \boldsymbol{\phi})\ e\ (s \models \boldsymbol{\Psi}) $$
$$s \models \exists \varphi \iff \pi \models \varphi\ per\ alcuni\ \pi \in Paths(s)$$
$$s \models \forall \varphi \iff \pi \models\ per\ tutti\ i\ \pi \in Paths(s)$$
Per un path $\pi$, la relazione di soddisfazione $\models$ per le formule di path è definita da:
$$\pi \models \bigcircle \boldsymbol{\phi} \iff \pi[1] \models \boldsymbol{\phi}$$
$$\pi \models \boldsymbol{\phi}\ \boldsymbol{U}\  \boldsymbol{\Psi} \iff \exists j \geqslant 0.(\pi[j] \models \boldsymbol{\Psi} \wedge (\forall 0 \leqslant k < j. \pi[k] \models \boldsymbol{\phi})$$
\end{defn}
\section{Model Checking di \ac{CTL}}
Data una formula \ac{CTL} $\phi$ ed un \ac{TS} l'obiettivo dell'algoritmo di Model Checking è quello di dire se il \ac{TS} soddisfa o meno la formula. Gli algoritmi proposti lavorano su formule in \ac{ENF}, definite dalla Grammatica~\ref{gra:enf}
\begin{Grammar}
	\begin{grammar}	
	
	\centering
	<$\phi$> ::= true | $a$ | $\phi_{1} \wedge \phi_{2}$ | $\neg \phi$ | $\exists\bigcircle\phi$ | $\exists\square\phi$ | $\exists(\phi_{1} \boldsymbol{U} \phi_{2})$
	
	\end{grammar}
	\caption{Grammatica delle formule in ENF}\label{gra:enf}
\end{Grammar}

il che non è limitate in quanto il Teorema~\ref{theorem:enf} dimostra che per ogni formula \ac{CTL} esiste la corrispondente formula in \ac{ENF}.
\begin{theor}
\label{theorem:enf}
Per ogni formula \ac{CTL} esiste un equivalente formula \ac{CTL} in \ac{ENF}
\end{theor}
\begin{proof}
Grazie alle leggi di dualità si ottengono delle regole di traduzione:
$$\forall\bigcircle \phi \equiv \neg \exists \bigcircle \neg \phi$$
$$\forall(\phi \boldsymbol{U} \Psi) \equiv \neg \exists( \Psi \boldsymbol{U} (\neg \phi \wedge \Psi)  )\wedge \neg\exists\neq\Psi$$
\end{proof}
L'algoritmo base, mostrato in Algoritmo~\ref{alg:base}, risolve ricorsivamente il problema di verificare se un determinato \ac{TS} soddisfa una formula $\phi$.
Fondamentalmente il calcolo consiste in un attraversamento dalle foglie alla radice dell'albero di parsing della formula sugli stati $\phi$. In questo albero i nodi rappresentano le sottoformule $\Psi$ di $\phi$, mentre le foglie rappresentano le proposizioni atomiche $a \in AP$ e la costante $true$.
Durante la computazione vengono calcolati ricorsivamente gli insiemi $Sat{\Psi}$ per ogni sottoformula $\Psi$ di $\phi$. In un generico passo intermedio il risultato della valutazione di un nodo figlio è usato e combinato in una maniera appropriata per stabilire il set di stati che soddisfa il nodo padre, chiamato $v$. Il tipo di computazione quando si raggiunge il nodo $v$ dipende dal tipo di operatore che contiene, che può essere $\wedge$, $\exists\bigcircle$ oppure $\exists\boldsymbol{U}$.\par
Il seguente teorema definisce come vengono generati gli insiemi di sottoformule.


\begin{theor}
Sia $TS = (S, Act, \rightarrow, I, AP, L)$ un \ac{TS} senza stati terminali. Per tutte le formule \ac{CTL} $\phi$, $\Psi$ su AP è vero che:

\begin{equation}\label{eq:te1}
Sat(true) = S
\end{equation}

\begin{equation}\label{eq:te2}
Sat(a) = \{s \in S | a \in L(s)\}
\end{equation}

\begin{equation}\label{eq:te3}
Sat( \phi \wedge \Psi) = Sat(\phi)  \cap Sat(\Psi)
\end{equation}

\begin{equation}\label{eq:te4}
Sat(\neg \phi) = S \backslash Sat(\phi)
\end{equation}

\begin{equation}\label{eq:te5}
Sat(\exists\bigcircle\phi) = \{s \in S | Post(s) \cap Sat(\phi) \neq \emptyset\}
\end{equation}

\begin{equation}\label{eq:te6}
\begin{aligned}
Sat(\exists(\phi \boldsymbol{U} \Psi))\ \text{è il più piccolo sottoinsieme T di S tale per cui } \\
(Sat(\Psi) \subseteq T \wedge (s \in Sat(\phi) \wedge Post(s) \cap T \neq \emptyset)) \implies s \in T
\end{aligned}
\end{equation}

\begin{equation}\label{eq:te7}
\begin{aligned}
Sat(\exists(\square\phi)) \text{è il più grande sottoinsieme T di S tale che} \\ 
T \subseteq Sat (\phi) \wedge s \in T \implies Post(s) \cap T \neq \emptyset
\end{aligned}
\end{equation}
\end{theor}
\begin{proof}
Da scrivere per \eqref{eq:te6} e \eqref{eq:te7}.
\end{proof}


\begin{algorithm}
\label{alg:base}
\caption{Algoritmo di model checking base per \ac{CTL}}
\begin{algorithmic}[1]
\Procedure{CTLModelChecking}{$TS, \phi$}
\ForAll{$i \leq |\phi|$}
\ForAll{$\Psi \in Sub(\phi)\ con\ |\Psi| = i$}
\State calcola $Sat(\Psi)$ da $Sat(\Psi^{'})$
\EndFor
\EndFor
\State \textbf{return} $I  \subseteq Sat(\phi)$
\EndProcedure
\end{algorithmic}
\end{algorithm}



\begin{algorithm}
\label{alg:until}
\caption{Algoritmo per $Sat(\exists(\phi \boldsymbol{U} \Psi)$)}
\begin{algorithmic}[1]
\Procedure{ComputeExistsUntil}{$TS, \phi \boldsymbol{U} \Psi$}
\State E $:= Sat(\Psi)$
\State T $:=$E
\While{$E \neq \varnothing $}
\State let $s^{1} \in E$
\State $E:=E \backslash \{s^{1}\}$
\ForAll{ $s \in Pre(s^{1})$}
\If{$s \in Sat(\phi)\backslash T$}
\State $E:= E \cup \{s\}$
\State $T:=T \cup\{s\}$
\EndIf
\EndFor
\EndWhile
\State \textbf{return} $T$
\EndProcedure
\end{algorithmic}
\end{algorithm}



\begin{algorithm}
\label{alg:always}
\caption{Algoritmo per $Sat(\exists \square \phi)$}
\begin{algorithmic}[1]
\Procedure{ComputeExistsAlways}{$TS, (\exists \square \phi)$}
\State S $:= S \backslash Sat(\phi)$
\State T $:=Sat(\phi)$
\ForAll{$s \in Sat(\phi)$}
\State $count[s] := |Post(s)|$
\EndFor
\While{$E \neq \varnothing $}
\State let $s^{1} \in E$
\State $E:=E \backslash \{s^{1}\}$
\ForAll{ $s \in Pre(s^{1})$}
\If{$s \in T$}
\State $count[s] := count[s]-1$
\If{$count[s] = 0$}
\State $T := T \backslash \{s\}$
\State $E := E \cup \{s\}$
\EndIf
\EndIf
\EndFor
\EndWhile
\State \textbf{return} $T$
\EndProcedure
\end{algorithmic}
\end{algorithm}



\begin{algorithm}
\label{alg:alternativealways}
\caption{Algoritmo alternativo per $Sat(\exists \square \phi)$}
\begin{algorithmic}[1]
\Procedure{AlternativeComputeExistsAlways}{$TS, (\exists \square \phi)$}
\State $S^{1} := Sat{\phi}$
\State $\rightarrow^{1} := \rightarrow \cap(S^{1} \times Act \times S^{1})$
\State $I^{1} := I \cap S^{1}$
\State $L^{1}(s) := L(s) | s \in S^{1}$
\State $TS[\phi] := (S^{1}, Act, \rightarrow^{1}, I^{1}, AP, L^{1}) $
\State $T := ComputeSSC(TS[\phi])$
\State return $Reach(I, T)$
\EndProcedure
\end{algorithmic}
\end{algorithm}



\subsection{Complessità dell'algoritmo}

\section{Model Checker in Python per \ac{CTL}}

\section{Esempi di utilizzo del Model Checker di \ac{CTL} in Python}

\begin{acronym}
\acro{CTL}{Computational Tree Logic}
\acro{LTL}{Linear Temporal Logic}
\acro{TS}{Transition System}
\acro{ENF}{Existential Normal Form}
\end{acronym}

\end{document}

























