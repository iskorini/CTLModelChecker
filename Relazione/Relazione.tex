\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[makeroom]{cancel}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage[]{acronym}
\usepackage{syntax}
\usepackage{newfloat}
\usepackage{float}
%\usepackage[LGRgreek]{mathastext}
\usepackage[osf,sc]{mathpazo}
\usepackage{eulervm}
\usepackage{MnSymbol}
\title{Relazione per l'approfondimento su Computational Tree Logic}
\author{Filippo Mameli, Federico Schipani}
\makeindex

\let\syntleft\relax
\let\syntright\relax
\grammarparsep=30pt
\DeclareFloatingEnvironment[
  fileext   = logr,
  listname  = {List of Grammars},
  name      = Grammatica,
  placement = H
]{Grammar}

\newtheorem{prop}{Proprietà}
\newtheorem{defn}{Definizione}

\begin{document}
\maketitle
\tableofcontents
\section{Introduzione a \ac*{CTL}}
\acf{CTL} è una logica proposta da Clarke e Emerson per far fronte ad alcuni problemi noti di \ac{LTL}. In \ac{LTL} il concetto di tempo è lineare, ciò vuol dire che in un determinato momento abbiamo un unico possibile futuro. Ciò comporta che una determinata formula $\phi$ è valida in uno stato $s$, se e solo se tutte le possibili computazioni che partono da quello stato soddisfano la formula. Più formalmente:
\begin{equation}\label{first}
    s \models \phi \iff \pi \models \phi \ \forall \  paths \  \pi \ che\  inizia\  in\  s
\end{equation}
Come si può notare dalla Formula \eqref{first} non è possibile imporre facilmente condizioni di soddisfacibilità solo su alcuni di questi path. Dato uno stato $s$, verificare che solo alcune computazioni soddisfano una formula $\phi$ può essere fatto usando la dualità tra l'operatore universale ed esistenziale. Quindi verificare  $ s \models  \exists \phi $ corrisponde a verificare $s \models \forall \neg \phi $. Se quest'ultima non è soddisfatta allora esisterà una computazione che soddisferà $\phi$, altrimenti non esisterà. \par
Questo sotterfugio non è possibile usarlo per proprietà più complicate. Per esempio la proprietà
\begin{prop}
\label{prop:first}
Per ogni computazione è sempre possibile ritornare in uno stato iniziale 
\end{prop}
non è possibile esprimerla in \ac{LTL}. Un tentativo potrebbe essere $\square\lozenge start$, dove $start$ indica uno stato iniziale. Tuttavia una formula di questo tipo è troppo forte, in quanto questa formula impone che una computazione ritorni sempre in uno stato iniziale, e non soltanto eventualmente. \par
\ac{CTL} risolve questi problemi introducendo una nozione di tempo che si basa sulle diramazioni. Quindi non abbiamo più un infinita sequenza di stati, ma un infinito albero di stati. Questo comporta che in un determinato momento avremo diversi possibili futuri.\par
La semantica di questa logica è definita in termini di infiniti alberi, dove ogni diramazione rappresenta un singolo percorso. L'albero quindi è una fedele rappresentazione di tutti i possibili path, e si può facilmente ottenere schiudendo il \ac{TS}.\par
In \ac{CTL} sono presenti quantificatori, definiti sui path, di tipo esistenziale ($\exists$) ed universale ($\forall$). La Proprietà $\exists\lozenge \psi$ dice che esiste una computazione che soddisfa $\lozenge\psi$, più intuitivamente vuol dire che esisterà almeno una possibile computazione nel quale uno stato $s$ che soddisfa $\psi$ verrà eventualmente raggiunto. Tuttavia questo non esclude la possibilità che ci possono essere computazioni per le quali questa proprietà non viene soddisfatta.
La proprietà \ref{prop:first} citata in precedenza è possibile ottenerla annidando quantificatori esistenziali ed universali in questo modo:
\begin{equation}
\label{second}
\forall\square\exists\lozenge start
\end{equation}
La Formula \eqref{second} si legge come: in ogni stato ($\square$) di ogni possibile computazione ($\forall$), è possibile ($\exists$) eventualmente ritornare in uno stato iniziale ($\lozenge start$).


\subsection{Sintassi di \ac{CTL}} 
\ac{CTL} ha una sintassi a due livelli, dove le formule sono classificate in \textit{formule sugli stati} e \textit{formule sui path}. 

\begin{Grammar}
	\begin{grammar}	
	
	\centering
	<$\boldsymbol{\phi}$> ::= true | a | $\boldsymbol{\phi}_{1} \wedge \boldsymbol{\phi}_{2}$ | $\neg \boldsymbol{\phi}$ | $	\exists \varphi$ | $\forall \varphi$ 
	
	\end{grammar}
	\caption{Grammatica per le formule sugli stati}\label{gra:stateformulae}
\end{Grammar}
Le prime sono definite dalla Grammatica \ref{gra:stateformulae} dove $a \in AP$ e $\varphi$ è una formula sui path.
\begin{Grammar}
	\begin{grammar}	
	
	\centering
	<$\varphi$> ::= $\bigcircle \boldsymbol{\phi}$ | $\boldsymbol{\phi}_{1}\ \boldsymbol{U}\  \boldsymbol{\phi}_{2}$ 
	
	\end{grammar}
	\caption{Grammatica per le formule sui path}\label{gra:pathformulae}
\end{Grammar}
Le \textit{formule sui path} sono invece definite dalla Grammatica \ref{gra:pathformulae}.
Intuitivamente si può dire che le formule sugli stati esprimono una proprietà su uno stato, mentre le formule sui path esprimono proprietà sui infinite sequenze di stati. Per esempio la formula $\bigcircle \phi$ è vera per un path se lo stato successivo, in quel path, soddisfa $\phi$. Una formula sugli stati può essere trasformata in una formula sui path aggiungendo all'inizio un quantificatore esistenziale ($\exists$) o universale ($\forall$). Per esempio la formula $\exists \varphi$ è valida in uno stato se esiste almeno un percorso che soddisfa $\varphi$.

\subsection{Semantica di \ac{CTL}}

Le formule \ac{CTL} sono interpretate sia sugli stati che sui path di un \ac{TS}. Formalmente, dato un \ac{TS}, la semantica di una formula è definita da due relazioni di soddisfazione: una per le formule di stato ed una per le formule di path.
Per le formule di stato è un tipo di relazione tra gli stati del \ac{TS} e la formula di stato. Si scrive che $s \models \boldsymbol{\phi}$ se e solo se la formula di stato $\boldsymbol{\phi}$ è vera nello stato $s$.\par
Per le formule di path la relazione $\models$ è una relazione definita tra un frammento di path massimale nel \ac{TS} e una formula di path. Si scrive che $\pi \models \varphi$ se e solo se il path $\pi$ soddisfa la formula $\varphi$.
\begin{defn}
Sia $a \in AP$ una proposizione atomica, $TS = (S, act, \rightarrow, I, AP, L)$ un \acf{TS} senza stati terminali, stati $s \in S$, $\boldsymbol{\phi}$, $\boldsymbol{\Psi}$ formule \ac{CTL} di stato e $\varphi$ una formula \ac{CTL} di path. La relazione di soddisfazione $\models$ per le formule di stato è definita come:
$$s \models a \iff a \in L(s)$$
$$s \models \neg \boldsymbol{\phi} \iff not\ s \models \boldsymbol{\phi}$$
$$s \models \boldsymbol{\phi} \wedge \boldsymbol{\Psi} \iff (s \models \boldsymbol{\phi})\ e\ (s \models \boldsymbol{\Psi}) $$
$$s \models \exists \varphi \iff \pi \models \varphi\ per\ alcuni\ \pi \in Paths(s)$$
$$s \models \forall \varphi \iff \pi \models\ per\ tutti\ i\ \pi \in Paths(s)$$
Per un path $\pi$, la relazione di soddisfazione $\models$ per le formule di path è definita da:
$$\pi \models \bigcircle \boldsymbol{\phi} \iff \pi[1] \models \boldsymbol{\phi}$$
$$\pi \models \boldsymbol{\phi}\ \boldsymbol{U}\  \boldsymbol{\Psi} \iff \exists j \geqslant 0.(\pi[j] \models \boldsymbol{\Psi} \wedge (\forall 0 \leqslant k < j. \pi[k] \models \boldsymbol{\phi})$$
\end{defn}
\section{Model Checking di \ac{CTL}}

\section{Model Checker in Python per \ac{CTL}}

\section{Esempi di utilizzo del Model Checker di \ac{CTL} in Python}

\begin{acronym}
\acro{CTL}{Computational Tree Logic}
\acro{LTL}{Linear Temporal Logic}
\acro{TS}{Transition System}
\end{acronym}

\end{document}

























